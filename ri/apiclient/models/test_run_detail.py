# coding: utf-8

"""
    Robust Intelligence REST API

    API methods for Robust Intelligence. Users must authenticate using the `rime-api-key` header.

    The version of the OpenAPI document: 1.0
    Contact: dev@robustintelligence.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from ri.apiclient.models.id import ID
from ri.apiclient.models.model_task import ModelTask
from ri.apiclient.models.safe_url import SafeURL
from ri.apiclient.models.test_category_type import TestCategoryType
from ri.apiclient.models.test_run_metrics import TestRunMetrics
from ri.apiclient.models.test_task_status import TestTaskStatus
from ri.apiclient.models.test_type import TestType
from ri.apiclient.models.time_interval import TimeInterval
from typing import Optional, Set
from typing_extensions import Self

class TestRunDetail(BaseModel):
    """
    TestRunDetail returns the details for a given test run.
    """ # noqa: E501
    test_run_id: Optional[StrictStr] = Field(default=None, description="Uniquely specifies a Test Run.", alias="testRunId")
    name: Optional[StrictStr] = Field(default=None, description="The name of the Test Run.")
    project_id: Optional[ID] = Field(default=None, alias="projectId")
    testing_type: Optional[TestType] = None
    model_task: Optional[ModelTask] = None
    ref_data_id: Optional[StrictStr] = Field(default=None, description="Uniquely specifies a reference dataset.", alias="refDataId")
    eval_data_id: Optional[StrictStr] = Field(default=None, description="Uniquely specifies an evaluation dataset.", alias="evalDataId")
    model_id: Optional[ID] = Field(default=None, alias="modelId")
    upload_time: Optional[datetime] = Field(default=None, description="The upload time of the test run.", alias="uploadTime")
    web_app_url: Optional[SafeURL] = Field(default=None, alias="webAppUrl")
    test_categories: Optional[List[TestCategoryType]] = Field(default=None, description="The list of child references to the category tests belonging to this test run.", alias="testCategories")
    metrics: Optional[TestRunMetrics] = None
    status: Optional[TestTaskStatus] = None
    progress: Optional[StrictStr] = Field(default=None, description="Human-readable succinct message about the progress of the test run.")
    rime_version: Optional[StrictStr] = Field(default=None, description="The version of Robust Intelligence that ran this test.", alias="rimeVersion")
    bin_time_interval: Optional[TimeInterval] = Field(default=None, alias="binTimeInterval")
    ref_data_sampling_pct: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Percentage of the reference dataset used for this test. If no sampling occurred, this will be 1.0.", alias="refDataSamplingPct")
    eval_data_sampling_pct: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Percentage of the evaluation dataset used for this test. If no sampling occurred, this will be 1.0.", alias="evalDataSamplingPct")
    schedule_id: Optional[ID] = Field(default=None, alias="scheduleId")
    __properties: ClassVar[List[str]] = ["testRunId", "name", "projectId", "testingType", "modelTask", "refDataId", "evalDataId", "modelId", "uploadTime", "webAppUrl", "testCategories", "metrics", "status", "progress", "rimeVersion", "binTimeInterval", "refDataSamplingPct", "evalDataSamplingPct", "scheduleId"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TestRunDetail from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of project_id
        if self.project_id:
            _dict['projectId'] = self.project_id.to_dict()
        # override the default output from pydantic by calling `to_dict()` of model_id
        if self.model_id:
            _dict['modelId'] = self.model_id.to_dict()
        # override the default output from pydantic by calling `to_dict()` of web_app_url
        if self.web_app_url:
            _dict['webAppUrl'] = self.web_app_url.to_dict()
        # override the default output from pydantic by calling `to_dict()` of metrics
        if self.metrics:
            _dict['metrics'] = self.metrics.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bin_time_interval
        if self.bin_time_interval:
            _dict['binTimeInterval'] = self.bin_time_interval.to_dict()
        # override the default output from pydantic by calling `to_dict()` of schedule_id
        if self.schedule_id:
            _dict['scheduleId'] = self.schedule_id.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TestRunDetail from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "testRunId": obj.get("testRunId"),
            "name": obj.get("name"),
            "projectId": ID.from_dict(obj["projectId"]) if obj.get("projectId") is not None else None,
            "testingType": obj.get("testingType"),
            "modelTask": obj.get("modelTask"),
            "refDataId": obj.get("refDataId"),
            "evalDataId": obj.get("evalDataId"),
            "modelId": ID.from_dict(obj["modelId"]) if obj.get("modelId") is not None else None,
            "uploadTime": obj.get("uploadTime"),
            "webAppUrl": SafeURL.from_dict(obj["webAppUrl"]) if obj.get("webAppUrl") is not None else None,
            "testCategories": obj.get("testCategories"),
            "metrics": TestRunMetrics.from_dict(obj["metrics"]) if obj.get("metrics") is not None else None,
            "status": obj.get("status"),
            "progress": obj.get("progress"),
            "rimeVersion": obj.get("rimeVersion"),
            "binTimeInterval": TimeInterval.from_dict(obj["binTimeInterval"]) if obj.get("binTimeInterval") is not None else None,
            "refDataSamplingPct": obj.get("refDataSamplingPct"),
            "evalDataSamplingPct": obj.get("evalDataSamplingPct"),
            "scheduleId": ID.from_dict(obj["scheduleId"]) if obj.get("scheduleId") is not None else None
        })
        return _obj


